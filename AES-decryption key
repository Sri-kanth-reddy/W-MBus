e <iostream>
#include <vector>
#include <string>
#include <iomanip>
#include <cctype>
#include <cstdint>
#include <stdexcept>
#include <algorithm>
#include "mbedtls/ccm.h"

// The L-Field (first byte) is 0xA1 (161 decimal). Total frame length is L+1 = 162 bytes.
const size_t EXPECTED_TOTAL_LEN = 162;

// Normalize hex string: remove spaces, newlines, and convert to lowercase
std::string normalize_hex(const std::string& input) {
    std::string result;
    for (char c : input) {
        // Only keep valid hex characters (0-9, a-f, A-F)
        if (std::isxdigit(static_cast<unsigned char>(c))) {
            result += std::tolower(static_cast<unsigned char>(c));
        }
    }
    return result;
}

// Convert hex string to byte vector
std::vector<uint8_t> hex_to_bytes(const std::string& hex) {
    if (hex.length() % 2 != 0) {
        throw std::invalid_argument("Hex string must have even length after normalization.");
    }
    std::vector<uint8_t> bytes;
    for (size_t i = 0; i < hex.length(); i += 2) {
        std::string byte_str = hex.substr(i, 2);
        uint8_t byte = static_cast<uint8_t>(std::stoul(byte_str, nullptr, 16));
        bytes.push_back(byte);
    }
    return bytes;
}

/**
 * @brief Constructs the 12-byte OMS Mode 5 Nonce (IV) from the 12-byte AAD (W-MBus header).
 *
 * Nonce Structure (12 bytes):
 * - Device ID (4 bytes, from AAD[5] to AAD[8])
 * - Manufacturer (2 bytes, from AAD[3] to AAD[4])
 * - Version (1 byte, from AAD[9])
 * - Type (1 byte, from AAD[10])
 * - Access Number (4 bytes: AAD[11] + 0x00 + 0x00 + 0x00)
 */
std::vector<uint8_t> construct_oms_nonce(const std::vector<uint8_t>& aad) {
    if (aad.size() != 12) {
        throw std::invalid_argument("AAD for Nonce construction must be 12 bytes.");
    }

    std::vector<uint8_t> iv(12);

    // 1. Device ID (4 bytes) - AAD[5] to AAD[8]
    std::copy(aad.begin() + 5, aad.begin() + 9, iv.begin());

    // 2. Manufacturer (2 bytes) - AAD[3] to AAD[4]
    std::copy(aad.begin() + 3, aad.begin() + 5, iv.begin() + 4);

    // 3. Version (1 byte) - AAD[9]
    iv[6] = aad[9];

    // 4. Type (1 byte) - AAD[10]
    iv[7] = aad[10];

    // 5. Access Number (4 bytes: ACC + 00 00 00)
    iv[8] = aad[11];
    iv[9] = 0x00;
    iv[10] = 0x00;
    iv[11] = 0x00;

    return iv;
}

// Print bytes in hex and ASCII
void print_payload(const std::vector<uint8_t>& data) {
    std::cout << "Decrypted payload (hex):\n";
    for (size_t i = 0; i < data.size(); ++i) {
        // Add a line break for every 16 bytes for cleaner output
        if (i > 0 && i % 16 == 0) std::cout << "\n";
        std::cout << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(data[i]);
    }
    std::cout << std::dec << "\n\n";

    std::cout << "Decrypted payload (ASCII): ";
    for (uint8_t b : data) {
        if (std::isprint(b)) {
            std::cout << static_cast<char>(b);
        } else {
            std::cout << '.';
        }
    }
    std::cout << "\n";
}

int main() {
    try {
        // --- CORRECT INPUTS ---

        // Key: Provided in the assignment
        std::string key_hex = "4255794d3dccfd46953146e701b7db68";

        // Message: Verified string, 324 characters (162 bytes) long.
        // Consolidated into a single literal string for robustness against concatenation issues.
        std::string msg_hex_singleline =
            "a144c5142785895070078c20607a9d00902537ca231fa2da5889be8df367"
            "3ec136aebfb80d4ce395ba98f6b3844a115e4be1b1c9f0a2d5ffbb92906aa388deaa"
            "82c929310e9e5c4c0922a784df89cf0ded833be8da996eb5885409b6c9867978dea"
            "24001d68c603408d758a1e2b91c42ebad86a9b9d287880083bb0702850574d7b511f08"
            "e9c209ed68e0374e9b01febfd92b4cb9410fdeaf7fb526b742dc9a8d068";

        // --- END CORRECT INPUTS ---

        // Normalize message
        std::string msg_hex = normalize_hex(msg_hex_singleline);
        size_t total_bytes = msg_hex.length() / 2;
        std::cout << "Normalized message length: " << msg_hex.length() << " chars (" << total_bytes << " bytes)\n";

        // Convert to bytes
        auto key = hex_to_bytes(key_hex);
        auto msg = hex_to_bytes(msg_hex);

        // Validate inputs
        if (key.size() != 16) {
            throw std::runtime_error("AES key must be 16 bytes (128 bits)");
        }
        if (msg.size() != EXPECTED_TOTAL_LEN) {
            throw std::runtime_error("Message length mismatch. Expected " + std::to_string(EXPECTED_TOTAL_LEN) +
                                     " bytes (from L-field A1), but found " + std::to_string(msg.size()) + " bytes.");
        }

        // --- CORRECT OMS PARSING (Security Mode 5) ---
        const size_t AAD_LEN = 12;   // Header (L-Field + Link Layer Header)
        const size_t MIC_LEN = 4;    // Authentication tag size for Mode 5

        // 1. Extract AAD (first 12 bytes of the telegram)
        std::vector<uint8_t> aad(msg.begin(), msg.begin() + AAD_LEN);

        // 2. Construct Nonce (IV) from AAD fields
        auto iv = construct_oms_nonce(aad);
        const size_t IV_LEN = iv.size(); // Always 12 bytes

        // 3. Extract MIC (last 4 bytes of the telegram)
        std::vector<uint8_t> mic(msg.end() - MIC_LEN, msg.end());

        // 4. Extract Ciphertext (everything between AAD end and MIC start)
        size_t ciphertext_start_index = AAD_LEN;
        size_t ciphertext_end_index = msg.size() - MIC_LEN;
        size_t ciphertext_len = ciphertext_end_index - ciphertext_start_index;

        std::vector<uint8_t> ciphertext(msg.begin() + ciphertext_start_index, msg.begin() + ciphertext_end_index);

        std::cout << "Parsed:\n";
        std::cout << "- AAD length: " << AAD_LEN << " bytes\n";
        std::cout << "- Nonce (IV) length: " << IV_LEN << " bytes (CONSTRUCTED from AAD)\n";
        std::cout << "- Ciphertext length: " << ciphertext_len << " bytes\n";
        std::cout << "- MIC length: " << MIC_LEN << " bytes\n";

        // Prepare output buffer
        std::vector<uint8_t> plaintext(ciphertext_len);

        // Initialize mbedTLS CCM context
        mbedtls_ccm_context ctx;
        mbedtls_ccm_init(&ctx);

        int ret = mbedtls_ccm_setkey(&ctx, MBEDTLS_CIPHER_ID_AES, key.data(), 128);
        if (ret != 0) {
            mbedtls_ccm_free(&ctx);
            throw std::runtime_error("Failed to set AES key (mbedTLS error: " + std::to_string(ret) + ")");
        }

        // Decrypt and authenticate
        ret = mbedtls_ccm_auth_decrypt(
            &ctx,
            ciphertext_len,
            iv.data(), IV_LEN,
            aad.data(), AAD_LEN,
            ciphertext.data(), plaintext.data(),
            mic.data(), MIC_LEN
        );
        mbedtls_ccm_free(&ctx);

        if (ret != 0) {
            if (ret == MBEDTLS_ERR_CCM_AUTH_FAILED) {
                throw std::runtime_error("Decryption failed: MIC authentication failed. Key, IV construction, or data segment boundaries are incorrect.");
            } else {
                throw std::runtime_error("Decryption failed (mbedTLS error: " + std::to_string(ret) + ")");
            }
        }

        std::cout << "\n✅ Decryption successful!\n\n";
        print_payload(plaintext);

    } catch (const std::exception& e) {
        std::cerr << "❌ Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
